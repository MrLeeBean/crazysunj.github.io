---
title: 类和接口(上)
date: 2017-01-09 15:28:59
tags: [Android,Java,类,接口]
toc: true
---

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类和接口是Java程序设计语言的核心，也是Java语言的基本抽象单元。那如何更好地利用这些元素，设计出更加有用、健壮和灵活的类和接口。

## 第1条:使类和成员的可访问性最小化
### 什么是设计良好的模块？
这个模块对于外部的其他模块而言，是否隐藏其内部数据和其他实现细节。

### 那么问题来了，为什么要进行信息隐藏呢？
<!--more-->
它可以有效地解除组成系统的各模块之间的耦合关系，使得这些模块可以独立地开发、测试、优化、使用、理解和修改。

到底是什么意思呢？Java程序设计语言提供了许多机制来协助信息隐藏。访问控制机制决定了类、接口和成员的可访问性。实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符共同决定的。

### 访问级别有哪些？
* 私有的(private):只有在声明该成员的顶层类内部才可以访问这个成员
* 包级私有的(package-private):声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被称为“缺省(default)访问级别”，如果没有为成员指定访问修饰符，就采用这个访问级别
* 受保护的(protected):声明该成员的类的子类可以访问这个成员(但有一些限制)，并且，声明该成员的包内部的任何类也可以访问这个成员
* 公有的(public):在任何地方都可以访问该成员

### SO?
是不是要把成员都变成私有的？私有成员和包级私有成员都是一个类的实现中的一部分，一般不会影响它的导出的API。有个小例外都是这个类实现了Serializable接口，因为这些域有可能会被“泄漏”到导出的API中。

如果把包级私有变成保护级别，虽会大大增强可访问性，但受保护的成员是类的导出的API的一部分，必须永远得到支持。(好好理解这句话)

### 实例域决不能是公有的
**如果域是非final得，或者是一个指向可变对象的final引用，那么一旦使这个域成为公有的，就放弃了对存储在这个域中的值进行限制的能力；这意味着，你也放弃了强制这个域不可变的能力。同时，当这个域被修改的时候，你也失去了对它采取任何行动的能力。因此，包含公有可变域的类并不是线程安全的。即使域是final的，并且引用不可变的对象，当把这个域变成公有的时候，也就放弃了“切换到一种新的内部数据表示法”的灵活性。**值得斟酌，斟酌，再三斟酌。

这个也适用于静态域，例外就是常量。这里有个严重的错误是，长度非零的数组总是可变的，所以，类具有公有的静态final数组域，或者返回这种域的访问方法，这几乎是错误地。那么如何改呢？

```
private static final String[] STRINGS={...};
pulic static final List<String> STRLIST=
Collections.unmodifiableList(Arrays.asList(STRINGS);
```

```
private static final String[] STRINGS={...};
public static final String[] get(){
    return STRINGS.clone();
}
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么哪种好呢？自己想去吧。总而言之，你应该始终尽可能地降低可访问性。你在仔细地设计了一个最小的公有API之后，应该防止把任何散乱的类、接口和成员变成API的一部分。除了公有静态final域的特殊情况之外，公有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都是不可变的。

## 第2条:在公有类中使用访问方法而非公有域
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果类可以在它所在的包的外部进行访问，就提供访问方法，以保留将来改变该类的内部表示法的灵活性。如果公有类暴露了它的数据域，要想在将来改变其内部表示法是不可能的，因为公有类的客户端代码已经遍布各处了。

### 然而？
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误——假设这些数据域确实描述了该类所提供的抽象。

<font color="red">小警告：</font>Java平台类库中有几个违反了“公有类不应该直接暴露数据域”的告诫。显著的例子包括java.awt包中的Point和Dimension类。

好像。。。域是不可变得，那么这种做法危害是不是小一点？

## 第3条:使可变性最小化
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候提供，并在对象的整个生命周期内固定不变。例如，Java提供的String、基本类型的包装类、BigInteger和BigDecimal。

要使类成为不可变，记住五条规则

* 不要提供任何会修改对象状态的方法 
* 保证类不会被扩展:这样可以防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为
* 使所有的域都是final的:通过系统的强制方式，这可以清楚地表明你的意图。而且，如果一个指向新创建实例的引用在缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必需确保正确的行为，如内存模型 
* 使所有的域都成为私有的:这样可以防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象
* 确保对于任何可变组件的互斥访问:如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用

请看这个类BigInteger

```
public BigInteger add(BigInteger value) {
      BigInt lhs = getBigInt();
      BigInt rhs = value.getBigInt();
      if (rhs.sign() == 0) {
          return this;
      }
      if (lhs.sign() == 0) {
          return value;
      }
      return new BigInteger(BigInt.addition(lhs, rhs));
}
```

上面这种称为函数的做法，常见的其他做法有过程的和命令的，但是它们在操作的时候回改变它们的状态。

可能它的做法缺点就是它需要创建一个新的实例，可能会耗资源，耗性能，我们可尝试静态工厂,达到线程安全

```
/** The {@code BigInteger} constant 0. */
public static final BigInteger ZERO = new BigInteger(0, 0);
/** The {@code BigInteger} constant 1. */
public static final BigInteger ONE = new BigInteger(1, 1);
/** The {@code BigInteger} constant 10. */
public static final BigInteger TEN = new BigInteger(1, 10);
/** The {@code BigInteger} constant -1. */
static final BigInteger MINUS_ONE = new BigInteger(-1, 1);
```

这样做有什么好处呢？ 

* 不可变对象比较简单
* 不可变对象本质上是线程安全的，它们不要求同步 
* 不仅可以共享不可变对象，甚至也可以共享它们的内部信息:例如BigInteger中

```
/** The sign of this. */
  transient int sign;
```

* 不可变对象为其他对象提供了大量的构件

那么针对缺点我们该怎么做？ 你猜
主要问题是有什么方法能够使类不可变？

最简单的就是让类加上final，其实还有一种更好的方法，那就是构造方法私有化，提供静态方法来提供实例。

**警告：**
如果你选择让自己的不可变类实现Serializable接口，并且它包含一个或者多个指向可变对象的域，就必须提供一个显式地readObject或者readResolve方法，或者使用ObjectOutputStream.writeUnshared和ObjectInputStream.readUnshared，即使默认的序列化形式是可以接受的，也是如此。否则攻击者可能从不可变的类创建可变的实例。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总之，坚决不要为每个get方法编写一个相应的set方法。除非有很好地理由要让类成为可变得类，否则就应该是不可变的。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有关于构造器初始化对象，最好是建立所有的约束关系，而不是提供公有的初始化方法，更不应该提供“重新初始化”方法，与所增加的复杂性相比，并没有带来太多的性能优势。例如TimeTask这个类。

## 第4条:复合优先于继承(类继承与类，非接口)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继承比较大的缺点就是打破了封装性，假设超类在下个版本发生了变化，那么子类就会得到破坏，好的继承应该需要子类跟着超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有良好的文档说明。

举个栗子？

假设有个类继承于HashSet，心类实现计数器的功能，即每增加一次，计数器加1。

```
@Override
public boolean add(T t){
    addCont++;
    return super.add(t);
}
@Override
public boolean addAll(Collection<? extends T> c){
    addCont+=c.size();
    return super.addAll(c);
}
```

很显然这是错的，以为在超类HashSet中，allAll中调用了add方法，那么本来是3的结果变成了6。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中有一种方法可以避免前面提到的所有问题。不能扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，而这就是复合。

我相信你还是一脸懵逼，哈哈。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们一个类实现Set接口，在构造函数中传入一个实现Set接口的类，然后重写方法，方法实现都是凋传入的对象的相应的方法，有点装饰着模式的味道，其实。。。这时候，我们想实现计数器的功能只要继承这个类就行了，懂了没？

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然这也有缺点，那就是这并不适合用在回调框架中，在回调框架中，对象把自身的引用传递给其他的对象，用于后续的调用。为什么？被包装起来的对象并不知道它外面的包装对象，所以它传递一个指向自身的引用，回调时避开了外面的包装对象。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一点想说的就是它并不会带来太多的性能影响和内存占用。

## 第5条:要么为继承而设计，并提供文档说明，要么就禁止继承
**注意点：**类的文档必须精确地描述覆盖每个方法所带来的影响。话句话说，该类必须有文档说明它可覆盖的方法的自用性。对于每个公有的或受保护的方法或者构造器，它的文档必须指明该方法或者构造器调用了哪些可覆盖的方法，是以什么顺序调用的，每个调用的结果又是如何影响后续的处理过程的(所谓可覆盖的方法，是指非final的，公有的或受保护的)。更一般地，类必须在文档中说明，在哪些情况下它会调用可覆盖的方法。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说了这么多，其实就是想告诉你，如果类不能安全地子类化或者没有文档的，要禁止子类化，要禁止。

那么问题来了，如何禁止呢？

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有两个方法，比较容易的办法是把这个类声明为final的，另一种办法是把所有构造器变成私有的，或者包级私有的，并增加一些公有的静态工厂来替代构造器。




