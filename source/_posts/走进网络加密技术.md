---
title: 走进网络加密技术
toc: true
date: 2018-12-03 09:46:08
tags: [对称加密,非对称加密,SSL/TLS]
mathjax: true
---
## 前言
客户端与服务端通信的时候，部分信息需要加密处理，比如我们的密码，你不会明文传输吧？其实这就涉及到网络加密技术。

>网络加密技术是为了保证网络、信息安全进行设计的，其是信息安全的核心技术，也是一种主动的信心安全防范措施，其原理利用了一定的加密算法，将可以直接读取的文件转化成不可以直接读取的秘密文件，在一定程度上能阻止非法用户截取或是掌握原始数据信息，进而保证数据的保密性。直接读取的文件变成不能直接读取文件的过程就是个加密过程，将不能直接读取的文件转化成可以直接读取的文件就是一个解密过程，加密、解密使用的可变参数就叫做密钥。

## 简介
网络加密技术其中一个种类就是对称加密技术和非对称加密技术。
### 对称加密技术
对称加密技术采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。

规则很简单，双方使用方式用同样的密钥进行加密和解密。

其中对称加密技术常用的是AES算法，DES算法渐渐少了，因为DES使用56位密钥，以现代计算能力，24小时内即可被破解。
### 非对称加密技术
非对称加密技术需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。

非对称加密的模式则是：

* 乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开
* 得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方
* 乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密。乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息

其中非对称加密技术的最经典算法莫过于RSA算法。
<!--more-->
## 基础知识
### 对称加密技术
AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同。本文均在密钥为128位下分析。

这是AES的加解密过程（网上找的图，自己懒得画了）：

![](/img/aes_flow.png)

看图可知，AES加密算法涉及4种操作：字节替代、行移位、列混淆和轮密钥加（下文会介绍）。其中会涉及数学知识（自行查看）[有限域GF(2^8)四则运算](https://blog.csdn.net/bupt073114/article/details/27382533)。
### 非对称加密技术
RSA算法我们需要了解一下[欧拉函数](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0)、[互质](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%B3%AA)、[欧拉定理](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_%28%E6%95%B0%E8%AE%BA%29)和[模逆元](https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0)。如果你已经对此very了解，那么请继续。

先介绍一下RAS的加密和解密公式。这里记明文为x，密文为y。

<table><tr><td bgcolor=#F5F5F5>$${x^e} \equiv y(modn)$$$${y^d} \equiv x(modn)$$</td></tr></table>

再简单介绍一下我们的公钥和私钥到底怎么生成的：

* 一般我们先取两个互质的质数p和q
* 记n=p*q
* 根据欧拉函数我们可以这样，φ(n)=φ(p\*q)=φ(p)\*φ(q)=(p-1)\*(q-1)
* 取e与φ(n)互质且范围在1<e<φ(n)，此时公钥生成(n,e)
* 根据模逆元公式，可求得e对同余φ(n)的模逆元d，此时私钥生成(n,d)

## 加解密
### 对称加密技术
我们对AES算法的4个步骤（字节替代、行移位、列混淆和轮密钥加）分别进行分析。
#### 字节替代
讲这个之前，我们需要知道2个表，S盒和逆S盒。

![](/img/sbox.png)

![](/img/inversesbox.png)

不要看了，看了也没用，我们需要用到这两个表进行字节替换，查一下就行了。所谓字节替换就是对一个字节的高4位和底4位，分为作为S盒/逆S盒的x和y，查到对应值，将该值对原字节替换。

举个例子：

![](/img/sbox_zijietihuan.png)

OK，是不是很简单，下一步。
#### 行移位
其原理，也很简单，正如名字所说，每行移位：：第一行保持不变，第二行循环左移8比特，第三行循环左移16比特，第四行循环左移24比特。其中，每格正好一个字节，其移动过程如下：

![](/img/hangyiwei.png)

#### 列混淆
列混淆相对较麻烦点，用到我一开始说的有限域GF(2^8)四则运算。过程如下图：

![](/img/liehunxiao.png)

我要是不举个例子，肯定懵逼，是的，主要是不熟悉GF(2^8)。我们以第一列为例（其中S00为0x11，S10为0x22，S20为0x33，S30为0x44）：

<table><tr><td bgcolor=#F5F5F5>$$\eqalign{
  & S'00 = (02 \bullet 11) \oplus (03 \bullet 22) \oplus (01 \bullet 33) \oplus (01 \bullet 44)  \cr
  & S'10 = (01 \bullet 11) \oplus (02 \bullet 22) \oplus (03 \bullet 33) \oplus (01 \bullet 44)  \cr
  & S'20 = (01 \bullet 11) \oplus (01 \bullet 22) \oplus (02 \bullet 33) \oplus (03 \bullet 44)  \cr
  & S'30 = (03 \bullet 11) \oplus (01 \bullet 22) \oplus (01 \bullet 33) \oplus (02 \bullet 44) \cr} $$</td></tr></table>

这里我们把S'00提出来详细步骤计算，剩下的都是一个道理。在此之前，我给大家科普个基础知识，可能没人认真去看GF(2^8)，一个数乘2，那么这个数左移1位，如果这个数移动之前最高位是1，那么需要将移动后的数与00011011做异或运算。

<table><tr><td bgcolor=#F5F5F5>$$\begin{align}
  S'00 & = (02 \bullet 11) \oplus (03 \bullet 22) \oplus (01 \bullet 33) \oplus (01 \bullet 44) \\\
   & = (02 \bullet 11) \oplus [(01 \oplus 02) \bullet 22] \oplus (01 \bullet 33) \oplus (01 \bullet 44) \\\
   & = 00100010 \oplus (01 \bullet 22) \oplus (02 \bullet 22) \oplus 00110011 \oplus 01000100 \\\
   & = 00100010 \oplus 00100010 \oplus 01000100 \oplus 00110011 \oplus 01000100 \\\
   & = 00110011 \end{align}$$</td></tr></table>

同理S'10=01000100，S'20=10011001，S'30=10101010。

这里展示一下逆向列混淆（稍微复杂点），同样的只列出S00的逆向计算过程，看是否等于0x11。

<table><tr><td bgcolor=#F5F5F5>$$\begin{align}
  S00 & = (0E \bullet 33) \oplus (0B \bullet 44) \oplus (0D \bullet 99) \oplus (09 \bullet AA) \\\
   & = [(02 \oplus 04 \oplus 08) \bullet 33)] \oplus (0B \bullet 44) \oplus (0D \bullet 99) \oplus (09 \bullet AA) \\\
   & = [(02 \bullet 33) \oplus (04 \bullet 33) \oplus (08 \bullet 33)] \oplus (0B \bullet 44) \oplus (0D \bullet 99) \oplus (09 \bullet AA) \\\
   & = (01100110 \oplus 11001100 \oplus 10000011) \oplus 11011010 \oplus 01101111 \oplus 10001101 \\\
   & = 00101001 \oplus 11011010 \oplus 01101111 \oplus 10001101 \\\
   & = 00010001 \\\
   & = 0x11 \end{align}$$ </td></tr></table>

同理可验证S10=0x22，S20=0x33，S30=0x44。

#### 轮密钥加
这个就更简单了，每轮的输出与密钥做一次异或就行了。还记得我一开始放的AES加密流程图吗？中间部分就是我们的密钥，那么我们的状态矩阵是如何与密钥异或的呢？

![](/img/lunmiyaojia.png)

那么还剩下最后一个问题，我们的密钥怎么来的呢？
#### 密钥扩展
密钥扩展主要是对密钥的初始化和生成每轮的密钥。

大致流程如下：

* 初始化4*4矩阵，与状态矩阵一样同样是128位（我们这里以128位为例），其中第一列组成的32位我们记为W[0]，剩余每列记为W[1]，W[2]，W[3]。
* 下轮的密钥是通过上轮的密钥计算出来的，这里取变量i，其范围是[4,43]。那么下轮的密钥计算公式可以写成：

<table><tr><td bgcolor=#F5F5F5>$$W[i] = \left\\{ {_{W[i - 1] \oplus g(W[i - 1]),(4 \leqslant i \leqslant 43,i\% 4 = 0)}^{W[i - 4] \oplus W[i - 1],(4 \leqslant i \leqslant 43,i\% 4 \ne 0)}} \right.$$</td></tr></table>

* 其中g函数的逻辑是对该w先左移8个比特，然后对每个字节进行S盒替换（字节替换章节有提到），最后与32位长度的常量(Rcon[i/4],0,0,0)进行异或操作，由于i最大取到43，同时又得满足取模4为0，那么i最大也就40，所以可以猜到Rcon是固定长度为10的一维数组。具体值如下：

<table><tr><td bgcolor=#F5F5F5>$$Rcon = \left\\{ {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36} \right\\}$$</td></tr></table>

上面大致流程我画了个流程图供大家理解：

![](/img/miyaokuozhan.png)

到这里，对称加密技术的AES算法告一段落了。
### 非对称加密技术
上一节基础知识我们知道了RSA的加解密算法，本节主要是对加解密算法的论证。而论证RSA算法，主要是论证解密算法。

1、由加密算法可知：

<table><tr><td bgcolor=#F5F5F5>$${x^e} \equiv y(\bmod n) \to y = {x^e} - kn$$</td></tr></table>

2、把y代入解密公式可得：

<table><tr><td bgcolor=#F5F5F5>$${({x^e} - kn)^d} \equiv x(\bmod n)$$</td></tr></table>

3、根据生成私钥时的模逆元公式可推导出：

<table><tr><td bgcolor=#F5F5F5>$$de \equiv 1(\bmod \varphi (n)) \to de = 1 + h\varphi (n)$$</td></tr></table>

4、第二步中，无论是d次幂还是几次幂，在模为n的情况下，结果均为：

<table><tr><td bgcolor=#F5F5F5>$${x^{de}}$$</td></tr></table>

5、再把第3步的结论代入第4步结论可得：

<table><tr><td bgcolor=#F5F5F5>$${x^{1 + h\varphi (n)}} \equiv x(\bmod n)$$</td></tr></table>

到第5步我们得到的公式只跟x和n有关系，我们不妨设x与n为互质关系，这里有个前提是x是小于n的正整数（满足欧拉函数）。

根据欧拉函数，得：

<table><tr><td bgcolor=#F5F5F5>$${x^{\varphi (n)}} \equiv 1(\bmod n) \to {x^{\varphi (n)}} = 1 + kn$$</td></tr></table>

两边同时h次幂，得：

<table><tr><td bgcolor=#F5F5F5>$${x^{h\varphi (n)}} = {(1 + kn)^h}$$</td></tr></table>

同第4步操作，取模为n，那么得：

<table><tr><td bgcolor=#F5F5F5>$${x^{h\varphi (n)}} \equiv 1(\bmod n) \to {x^{h\varphi (n)}} = 1 + kn$$</td></tr></table>

两边同时乘x，取模n，得证：

<table><tr><td bgcolor=#F5F5F5>$${x^{1 + h\varphi (n)}} = x + knx \to {x^{1 + h\varphi (n)}} \equiv x(\bmod n)$$</td></tr></table>

OK，我们很顺利地验证了解密算法，还剩一种情况，x与n不互质的情况。

我们冷静分析一下，n=pq，而x与n不互质，那么必存在一个正整数系数k与p或q相乘和x相等。这里不妨设x=kp，又因为p和q是互质的两个质数，同时x小于n，所以x与q必互质。

根据以上已知条件，可得（根据什么定理我就不写了，就开始列出来的那么几个）：

<table><tr><td bgcolor=#F5F5F5>$${x^{\varphi (q)}} \equiv 1(\bmod q) \to {x^{q - 1}} = 1 + kq \to {(kp)^{q - 1}} = 1 + kq$$</td></tr></table>

或许到这里就懵逼，啥呀，这是啥呀！冷静一下，看一眼q-1，想一想欧拉函数φ(n)=(p-1)*(q-1)。我们两边同时h(p-1)次幂，得：

<table><tr><td bgcolor=#F5F5F5>$${(kp)^{h(p - 1)(q - 1)}} = {(1 + kq)^{h(p - 1)}} \to {(kp)^{h\varphi (n)}} \equiv 1(\bmod q) \to {(kp)^{h\varphi (n)}} = 1 + tq$$</td></tr></table>

两边再同时乘以kp，得证：

<table><tr><td bgcolor=#F5F5F5>$${(kp)^{1 + h\varphi (n)}} = kp + tkpq \to {x^{1 + h\varphi (n)}} = x + tkn \to {x^{1 + h\varphi (n)}} \equiv x(\bmod n)$$</td></tr></table>

## 优缺点
### 对称加密技术
#### 优点
算法公开、计算量小、加密速度快、加密效率高。
#### 缺点
秘钥的管理和分发非常困难，不够安全。如果一方的秘钥被泄露，那么加密信息也就不安全了。
### 非对称加密技术
#### 优点
安全性更高，公钥是公开的，秘钥是自己保存的。
#### 缺点
加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
## 技术应用
HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险。而采用HTTPS可以避免这些风险，其原理同样采用上述的对称加密和非对称加密。大致步骤如下：

* 客户端把自己支持的一套加密算法和一个随机数random_C发给服务端
* 服务端选择其中一种加密算法和hash算法，并把自己的证书（一般为CA证书）和一个随机数random_S发给客户端
* 客户端收到证书，验证其合法性，如果合法（例如证书是否合法是否过期，客户端公钥是否能解密数字签名，证书的域名与正在访问的域名是否一致等）或者用户选择信任进入下一步
* 客户端生成随机数Pre-master（会用公钥加密传给服务端），此时客户端通过random_C、random_S和Pre-master计算出一个对称密钥，利用服务端选择的hash算法对握手信息进行hash（生成摘要），然后用对称密钥对摘要进行加密（生成数字签名）并同时传给服务端
* 服务端根据这3个随机数同样计算出对称密钥（DH算法），再用其对数字签名解密得到摘到，然后与客户端传来的摘要对比，如果一致，与客户端同样的操作再来一遍并传给客户端
* 客户端与上一步服务端同样操作判断摘要的一致性，如果一致，之后就用该对称密钥进行通信，TSL/SSL握手阶段结束

## 结束语
到这里，网络加密技术告一段落了，讲解的差不多也只是其冰山一角，算是对自己知道的一个小总结，同样希望这个能帮助到你。