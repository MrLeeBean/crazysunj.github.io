---
title: 模板方法模式
date: 2017-02-13 14:17:30
tags: [Android,Java,模板方法模式]
---

首先，我们先来个小场景：冲泡咖啡和茶

那么冲泡方法：

|咖啡	|茶|
|:-:|:-:|
|1.把水煮沸	|1.把水煮沸|
|2.用沸水冲泡咖啡	|2.用沸水浸泡茶叶|
|3.把咖啡倒进杯子|	3.把茶倒进杯子|
|4.加糖和咖啡	|4.加柠檬|

现在我们代码简单实现

咖啡：

```
/**
 * Created by sunjian on 2017/2/13.
 */
public class Coffee {
    void prepareRecipe() {
        boilWater();
        brewCoffeeGrinds();
        pourInCup();
        addSugarAndMilk();
    }
    public void boilWater() {
        Log.d("Coffee", "boilWater");
    }
    public void brewCoffeeGrinds() {
        Log.d("Coffee", "brewCoffeeGrinds");
    }
    public void pourInCup() {
        Log.d("Coffee", "pourInCup");
    }
    public void addSugarAndMilk() {
        Log.d("Coffee", "addSugarAndMilk");
    }
}
```

茶：

```
/**
 * Created by sunjian on 2017/2/13.
 */
public class Tea {
    void prepareRecipe() {
        boilWater();
        steepTeaBag();
        pourInCup();
        addLemon();
    }
    public void boilWater() {
        Log.d("Tea", "boilWater");
    }
    public void steepTeaBag() {
        Log.d("Tea", "steepTeaBag");
    }
    public void pourInCup() {
        Log.d("Tea", "pourInCup");
    }
    public void addLemon() {
        Log.d("Tea", "addLemon");
    }
}
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显prepareRecipe(),boilWater(),pourInCup()这3个方法重复了，那么我们把它定义为抽象方法，但是prepareRecipe()方法最好不要曝露出去，因此我们这样实现：

```
/**
 * Created by sunjian on 2017/2/13.
 */
public abstract class CaffeineBeverage {
    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }
    public abstract void addCondiments();
    public void pourInCup() {
        Log.d("CaffeineBeverage", "pourInCup");
    }
    public abstract void brew();
    public void boilWater() {
        Log.d("CaffeineBeverage", "boilWater");
    }
}
```

这样一来，我们只要使Coffee和Tea分别继承CaffeineBeverage，重写brew()和addCondiments()即可。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里已经，定义有点明显了，好像是模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现，该例子中prepareRecipe()方法就是一个模板方法，里面定义了咖啡和茶的冲泡算法，这里我想说一下，算法并不是什么很高端的东西，生活中到处是算法，可能它用在计算机中比较合适，算法简单点说就是一种技巧，不要问我什么是技巧。

好了，我们来看看模板方法模式的官方定义

	在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
	
类图（请叫我盗图狂魔）：

![](/img/concrete1.png)

而模板方法模式的一个精髓就是hook(钩子)，简单来说，钩子就是一个判断条件。接下来我们结合我们的例子告诉你什么是钩子。

```
/**
 * Created by sunjian on 2017/2/13.
 */
public abstract class CaffeineBeverageWithHook {
    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        if (isAddCondiments()) {
            addCondiments();
        }
    }
    public abstract void addCondiments();
    public void pourInCup() {
        Log.d("CaffeineBeverage", "pourInCup");
    }
    public abstract void brew();
    public void boilWater() {
        Log.d("CaffeineBeverage", "boilWater");
    }
    public boolean isAddCondiments() {
        return true;
    }
}
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子类可以根据用户的需要到底要不要加东西，默认返回True，表明要加，如果想不加，经过逻辑判断返回false即可，这就是钩子，就是这么简单。

而这里我们说一说一个设计原则：好莱坞原则

	别调用我们，我们会调用你。
	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像我们例子中，Coffee和Tea的冲泡方法步骤依赖于CaffeineBeverageWithHook父类的prepareRecipe()，子类只要实现相应的方法就行了，而具体怎么调用，不用管。

差不多接近尾声了，我们总结一下要点。

* “模板方法”定义了算法的步骤，把这些步骤的实现延迟到子类
* 模板方法模式为我们提供了一种代码复用的重要技巧
* 模板方法的抽象类可以定义具体方法、抽象方法和钩子
* 抽象方法由子类实现
* 钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它
* 为了防止子类改变模板方法的算法，可以将模板方法申明为final
* 好莱坞原则告诉我们，将决策权放在高层模板中，以便决定如何以及时调用底层模块
* 你将在真实世界代码中看到模板方法模式的许多变体，不要将期待它们全部是一眼就可以被你认出的
* 策略模式和模板方法模式都封装算法，一个用组合，一个用继承
工厂方法是模板方法的一种特殊版本
