---
title: 单例模式
date: 2016-12-29 13:25:48
tags: [Android,Java,单例模式]
toc: true
---


## 定义
确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

## 类型
创建类模式

## 类图

![](/img/singleton1.gif)

## 类图知识点
* 类图分为三部分，依次是类名、属性、方法
* 以<<开头和以>>结尾的为注释信息
* 修饰符+代表public，-代表private，#代表protected，什么都没有代表包可见
* 带下划线的属性或方法代表是静态的

单例模式应该是23种设计模式中最简单的一种模式了。它有以下几个要素：

* 私有的构造方法
* 指向自己实例的私有静态引用
* 以自己实例为返回值的静态的公有的方法

## 优点
<!--more-->
* 在内存中只有一个对象，节省内存空间
* 避免频繁的创建销毁对象，可以提高性能
* 避免对共享资源的多重占用
* 可以全局访问

## 适用场景

* 需要频繁实例化然后销毁的对象
* 创建对象时耗时过多或者耗资源过多，但又经常用到的对象
* 有状态的工具类对象
* 频繁访问数据库或文件的对象
* 要求只有一个对象的场景

## 注意事项

* 只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象
* 不要做断开单例类对象与类中静态引用的危险操作
* 多线程使用单例使用共享资源时，注意线程安全问题

## 争议

争议点：如果一个单例对象在内存中长久不用，会被jvm认为是一个垃圾，在执行垃圾收集的时候会被清理掉。

我比较赞成某大神的观点是：在hotspot虚拟机1.6版本中，除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。

附上链接：[单例模式与垃圾回收](http://blog.csdn.net/zhengzhb/article/details/7331354)

## 实现方法（7种）

### 1.饿汉模式

```
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {
    }
    public static Singleton getInstance() {
        return instance;
    }
}
```

利弊：这种方式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快。 这种方式基于类加载机制避免了多线程的同步问题，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。

### 2.懒汉模式（线程不安全）

```
public class Singleton {
    private static Singleton instance;
    private Singleton() {
    }
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

利弊：懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。

### 3.懒汉模式（线程安全)

```
public class Singleton {
    private static Singleton instance;
    private Singleton() {
    }
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

利弊：这种写法能够在多线程中很好的工作，但是每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，而且大部分时候我们是用不到同步的，所以不建议用这种模式。

### 4.双重检查模式 （DCL）

```
public class Singleton {
    private volatile static Singleton instance;
    private Singleton() {
    }
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

利弊：这种写法在getSingleton方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。在这里用到了volatile(线程在每次使用变量的时候，都会读取变量修改后的值),在这里使用volatile会或多或少的影响性能，但考虑到程序的正确性，牺牲这点性能还是值得的。 DCL优点是资源利用率高，第一次执行getInstance时单例对象才被实例化，效率高。缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。DCL虽然在一定程度解决了资源的消耗和多余的同步，线程安全等问题，但是他还是在某些情况会出现失效的问题，也就是DCL失效，建议用静态内部类单例模式来替代DCL。

### 5.静态内部类单例模式

```
public class Singleton {
    private Singleton() {
    }
    public static Singleton getInstance() {
        return SingletonHolder.sInstance;
    }
    private static class SingletonHolder {
        private static final Singleton sInstance = new Singleton();
    }
}
```

利弊：第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。

### 6.枚举单例

```
public enum Singleton {
    INSTANCE;
    public void doSomeThing() {
    }
}
```

利弊：默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，上述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。反序列化操作提供了readResolve方法，这个方法可以让开发人员控制对象的反序列化。在上述的几个方法示例中如果要杜绝单例对象被反序列化是重新生成对象，就必须加入如下方法：

```
private Object readResolve() throws ObjectStreamException {
     return singleton;
}
```
枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。

### 7.使用容器实现单例模式

```
public class SingletonManager {
    private static Map<String, Object> objMap = new HashMap<String, Object>();
    private SingletonManager() {
    }
    public static void registerService(String key, Object instance) {
        if (!objMap.containsKey(key)) {
            objMap.put(key, instance);
        }
    }
    public static Object getService(String key) {
        return objMap.get(key);
    }
}
```

利弊：用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。

