---
title: 类和接口(下)
date: 2017-01-12 10:59:45
tags: [Android,Java,接口,类]
---

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类和接口是Java程序设计语言的核心，也是Java语言的基本抽象单元。那如何更好地利用这些元素，设计出更加有用、健壮和灵活的类和接口。

## 第6条:接口优于抽象类

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先得说说接口与抽象类的区别：抽象类允许包含某些方法的实现，但是接口则不允许；更重要的一个区别在于，为了实现由抽象类定义的类型，类必须成为抽象类的一个子类，而继承只能单继承。

* 现有的类可以很容易被更新，以实现新的接口:就是说A和B两个类分别继承抽象类和实现接口，假设我们要增加新方法，实现接口的很容易实现新的方法
* 接口是定义mixin(混合类型)的理想选择:mixin就是混合类型的意思，很明显了，说的就是抽象类只能单继承，想拥有更多的功能只能提高类的层次结构，而接口可以多实现
* 接口允许我们构造非层次结构的类型框架:说的跟第二条差不多，就是说多实现，不打破类的层次结构

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然接口不允许包含方法的实现，但是接口来定义类型并不妨碍你为程序员提供实现上的帮助。通过对你导出的每个重要接口都提供一个抽象的骨架实现类，把接口和抽象类的优点结合起来。

例如：
<!--more-->
```
static List<Integer> intArrayAsList(final int[] a) {
  if (a == null)
      throw new NullPointerException();
  return new AbstractList<Integer>() {
      @Override
      public Integer get(int index) {
          return a[index];
      }
      @Override
      public Integer set(int index, Integer element) {
          int oldVal = a[index];
          a[index] = element;
          return oldVal;
      }
      @Override
      public int size() {
          return a.length;
      }
  };
}
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;骨架实现的美妙之处在于，它们为抽象类提供了实现上的帮助，但又不强加“抽象类被用作类型定义使”所特有的严格限制。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一种叫模拟多重继承的方法，就是实现这个接口的类可以把对于接口方法的调用，转发到一个内部私有类的实例上，这个内部私有类扩展了骨架实现类。

我知道你需要例子，其实例子都在源码中，我们来看看AbstractMapEntry

```
public abstract class AbstractMapEntry<K,V> implements Map.Entry<K,V> {
public abstract K getKey();
public abstract V getValue();
public V setValue(V value) {
  throw new UnsupportedOperationException();
}
@Override
  public boolean equals(Object o) {
      if (o == this)
          return true;
      if (!(o instanceof Map.Entry))
          return false;
      Map.Entry e = (Map.Entry) o;
      return equals(getKey(), e.getKey()) && equals(getValue(), e.getValue());
  }
  @Override
  public int hashCode() {
      return hashCode(getKey()) ^ hashCode(getValue());
  }
  private static boolean equals(Object o1, Object o2) {
      return o1 == null ? o2 == null : o1.equals(o2);
  }
  private static int hashCode(Object object) {
      return object == null ? 0 : object.hashCode();
  }
}
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很简单，抽象类和接口的结合。还有AbstractMap.SimpleEntry就是个例子。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要知道，接口一旦被公开发行，并且已被广泛实现，再想改变这个接口几乎是不可能的。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总之，接口通常是定义允许多个实现的类型的最佳途径。这条规则有个例外，即当演变的容易性比灵活性和功能更为重要的时候。

## 第7条:接口只用于定义类型

有一种接口被称为常量接口，它不满足上面的条件，所以尽量不用。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么这么说？玩意类实现这个接口呢？首先不说没什么价值可言，主要是如果在将来的发行版本中，这个类被修改了，它不再需要使用这些常量了，它依然必须实现这个接口，以确保二进制兼容性。如果非final类实现了常量接口，它的所有子类的命名空间也会被接口中的常量所“污染”。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你只是想导出常量，那么，你可以直接把这些常量添加到这个类或者这个接口中；或者使用不可实例化的工具类来导出常量。

## 第8条:类层次优于标签类

废话不多说，看例子：

```
class Figure {
  enum Shape {RECTANGLE, CIRCLE}
  ;
  final Shape shape;
  double length;
  double width;
  double radius;
  Figure(double radius) {
      shape = Shape.CIRCLE;
      this.radius = radius;
  }
  Figure(double length, double width) {
      shape = Shape.RECTANGLE;
      this.length = length;
      this.width = width;
  }
  double area() {
      switch (shape) {
          case RECTANGLE:
              return length * width;
          case CIRCLE:
              return Math.PI * (radius * radius);
          default:
              throw new AssertionError();
      }
  }
}
```

一句话，标签类过于冗长、容易出错，并且效率低下。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何修改呢，把分类分别以内部类继承的形式内嵌Figure类中，这也是我们所说的单一原则。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，标签类很少有适用的时候。当你想要编写一个包含显式标签域的类时，应该考虑一下，这个标签是否可以取消，这个类是否可以用类层次来代替。当你遇到一个包含标签域的现有类时，就要考虑将它重构到一个层次结构中去。

## 第9条:用函数对象表示策略

这个你得去看看策略模式了，我后期也会发布。

简单举个栗子：

```
class StringComparator{
  public int compare(String s1,String s2){
      return s1.length()-s2.length();
  }
}
```

更好的就是利用接口，这样的匿名类的使用就越来越广泛。

## 第10条:优先考虑静态成员类

首先我们的了解一个常识，嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为它的外部类提供服务。一共四种:静态成员类、非静态成员类、匿名类和局部类<font color="red">(万恶的内存泄漏)</font>。

* 静态成员类:其实它就是一个普通类，只不过放在了另一个类的内部。
非静态成员类:当非静态成员类的实例被创建的时候，它和外围实例之间的关联关系也随之被建立起来；而且这种关联以后不能被修改
* 匿名类:它并不是外围类的一个成员，它只有在使用的同事被声明和实例化。当且仅当匿名类出现在非静态的环境中时，它才有外围实例，而匿名类也是我们常见的函数对象(函数编程)
* 局部类:它可以声明在局部变量可以声明的地方


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大总结：如果一个嵌套类需要在单个方法之外任然是可见的，或者它太长了，不适合于放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的；否则，就做成静态的。假设这个嵌套类属于一个方法的内部，如果你只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类；否则，就做成局部类。



