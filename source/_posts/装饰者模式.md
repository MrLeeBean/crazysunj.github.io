---
title: 装饰者模式
date: 2017-02-13 15:47:48
tags: [Android,Java,装饰者模式]
toc: true
---

## 定义
	动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从定义中，我们知道其实继承也可以达到“同样的”效果，那又为什么会出现装饰者模式呢？

首先我们先来了解开放封闭原则。

	类应该对扩展开放，对修改封闭。
	
问题来了，为什么会出现这样的原则呢？

这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。

这样说，确实不好理解，太官话了。那么我来解答几个关于开放封闭的问题。

### 如何将某件东西设计成可以扩展，又禁止修改？
	许多模式是长期经验的实证，可通过提供扩展的方法来保护代码免于被修改。在本章，将看到使用装饰者模式的一个好例子，完全遵循开放封闭原则。
	
### 如何让设计的每个部分都遵循开放封闭原则？
	通常，你办不到。要让oo设计同时具备开放性和封闭性，又不修改现有的代码，需要花费许多时间和努力。一般来说，我们实在没有闲工夫把设计的每个部分都这么设计(而且，就算做得到，也可能只是一种浪费)。遵循开放封闭原则，通常会引入新的抽象层次，增加代码的复杂度。你需要把注意力集中在设计中最有可能改变的地方，然后应用开放封闭原则。
<!--more-->
### 那么哪些地方的改变更重要呢？
	这牵涉到设计oo系统的经验，和对你工作领域的了解。多看一些其他的例子可以帮你学习如何辨别设计中的变化区。
	
## 简介

废话不多说，上图

![](/img/decorator1.png)

在装饰模式中的各个角色有：

* 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象
* 具体构件（Concrete Component）角色：定义一个将要接收附加责任的类
* 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。
* 具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任

其实，我知道你还是不懂，没关系，我们先说一波装饰者的优缺点。

优点：

* Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性
* 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合

缺点：

* 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性
* 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂
* 装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择

尝试记住优缺点，好了，现在我们研究研究到底怎么回事？我们来研究研究权威的I/O框架。

上一张简单的架构图。

![](/img/decorator2.png)

然后我们去探索下，源码到底怎么回事，还记得这样的用法吗？

```
new BufferedInputStream(new FileInputStream(file));
```

走进BufferedInputStream，我们就看到显眼的继承关系

```	
public class BufferedInputStream extends FilterInputStream
```

然后我们看看它的构造函数

```
public BufferedInputStream(InputStream in) {
   this(in, defaultBufferSize);
}
public BufferedInputStream(InputStream in, int size) {
   super(in);
   if (size <= 0) {
       throw new IllegalArgumentException("Buffer size <= 0");
   }
   buf = new byte[size];
}
```

很显然，在构造函数里，传入一个输入流，从结构层次不难发现BufferedInputStream继承于FilterInputStream，而FilterInputStream继承于InputStream

我们往下看，我们用的比较多的，可能就是这个方法了read(byte b[], int off, int len)

先看看BufferedInputStream中的read方法

```
public synchronized int read(byte b[], int off, int len)
        throws IOException
{
    getBufIfOpen(); // Check for closed stream
    if ((off | len | (off + len) | (b.length - (off + len))) < 0) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    }
    int n = 0;
    for (;;) {
        int nread = read1(b, off + n, len - n);
        if (nread <= 0)
            return (n == 0) ? nread : n;
        n += nread;
        if (n >= len)
            return n;
        // if not closed but no bytes available, return
        InputStream input = in;
        if (input != null && input.available() <= 0)
            return n;
    }
}
```

再来看看FilterInputStream中的read方法

```
public int read(byte b[], int off, int len) throws IOException {
    return in.read(b, off, len);
}
```

越来越明显了，在看看InputStream中的read方法

```
public int read(byte b[], int off, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (off < 0 || len < 0 || len > b.length - off) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    }
    int c = read();
    if (c == -1) {
        return -1;
    }
    b[off] = (byte)c;
    int i = 1;
    try {
        for (; i < len ; i++) {
            c = read();
            if (c == -1) {
                break;
            }
            b[off + i] = (byte)c;
        }
    } catch (IOException ee) {
    }
    return i;
}
```

FilterInputStream的read很实在，直接调用InputStream的read
而BufferedInputStream中read进行了装饰，我们可以看到read1这个方法，走进入看

```
private int read1(byte[] b, int off, int len) throws IOException {
    int avail = count - pos;
    if (avail <= 0) {
        /* If the requested length is at least as large as the buffer, and
           if there is no mark/reset activity, do not bother to copy the
           bytes into the local buffer.  In this way buffered streams will
           cascade harmlessly. */
        if (len >= getBufIfOpen().length && markpos < 0) {
            return getInIfOpen().read(b, off, len);
        }
        fill();
        avail = count - pos;
        if (avail <= 0) return -1;
    }
    int cnt = (avail < len) ? avail : len;
    System.arraycopy(getBufIfOpen(), pos, b, off, cnt);
    pos += cnt;
    return cnt;
}
```

我们就直接找read方法就行了getInIfOpen().read(b, off, len)，那么getInIfOpen()又是什么呢？

```
private InputStream getInIfOpen() throws IOException {
    InputStream input = in;
    if (input == null)
        throw new IOException("Stream closed");
    return input;
}
```

很明显，in就是我们所传进来的InputStream,我们对FileInputStream进行了包装，BufferedInputStream是一种缓冲流，因为FileInputStream 里面的read(buffer)方法，直接读取到自己的buffer里面，这个是读取到一个数组里面，jvm里面创建一个新对象都需要耗费时间的，而且每一次read都要执行I/O操作，比较慢。创建 BufferedInputStream时即创建了一个内部缓冲区数组。

Java没有这样做，直接继承FileInputStream，重写它的read的方法，而是用组合的方式。

这么复杂的I/O框架都是这样做，那么你明白为什么这样做么？

## 要点

* 继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式
* 在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码
* 组合和委托可用于在运行时动态地加上新的行为
* 除了继承，装饰者模式也可以让我们扩展行为
* 装饰者模式意味着一群装饰者类，这些类用来包装具体组件
* 装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）
* 装饰者可以在被装饰者行为前面与/或后面加上自己的行为，甚至被装饰者的行为整个取代掉，而达到特定的目的
* 你可以用无数个装饰者包装一个组件
* 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型
* 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂
