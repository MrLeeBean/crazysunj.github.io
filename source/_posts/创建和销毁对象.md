---
title: 创建和销毁对象
date: 2016-12-29 13:26:29
tags: [Android,Java,对象]
toc: true
---

## 第一条 考虑用静态工厂方法代替构造器
### 优势：
* 他们有名称，根据静态方法很容易区分返回对象的区别
* 不必在每次调用他们的时候都创建一个新对象，我们可以使用事前构造好的实例或者将构造好的实例缓存起来，进行重复利用，从而避免不必要的重复对象
* 可以在返回原返回类型的任何子类型的对象，这样我们在选择返回对象的类时就有了更大的灵活性，如Java Collections类，里面封装了许多私有类，返回不同的类，提供不同的功能
* 在创建参数化类型实例的时候，他们使代码变得更加简洁，因为有的时候，构造函数参数比较复杂

### 缺点：
* 类如果不含公有的或者受保护的构造器，就不能被子类化，例如Conllections类，返回的类为私有类，导致该类不能被继承，但是我们能够使用复合(composition)
* 它们与其他的静态方法实际上没啥任何区别，如果使用静态工厂方法，很难查明类是如何被实例化的

### 总结：
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态工厂方法和公有构造器都各有用处，我们需要理解它们各自的长处。静态工厂通常更适合，因此切忌第一反应就是提供公有的构造器，而不先考虑静态工厂。
<!--more-->
## 第二条：遇到多个构造器参数时要考虑用构建器
### 原因：
静态工厂和构造器都不能很好地扩展到大量的可选参数。

### 解决方案：
* 重叠构造器模式，但是当有许多参数的时候，客户端代码会很难编写，并且仍然较难以阅读
* JavaBeans模式，但是在构造过程中JavaBeans可能处于不一致的状态且该模式阻止了把类做成不可变的可能，程序员需要付出额外的努力来确保它的线程安全
* Builder模式，builder对象类似于javavbean，构建完builder对象后以参数形式传入原来想构造的类中，从而生成不可变的对象。而且Builder模式十分灵活，可以利用单个builder构建多个对象(可以使用泛型)，缺点可能就需要创建不必要的builder对象，增加了不必要的开销，如果是比较注重性能的场合，那就成问题了

### 总结：
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是种不错的选择，特别是当大多数参数都是可选的时候。与使用传统的重叠构造器模式相比，使用Builder模式的客户端代码将更易于阅读和编写，构造器也比JavaBeans更加安全。

## 第三条：用私有构造器或者枚举类型强化Singleton属性
本条主要讲单例模式，具体参考单例模式笔记，本条几点注意的地方：

* 当把类构建成单例的时候，要防止用户通过反射机制调用构造器，我们可以修改构造器，让它在被要求创建第二个实例的时候抛出异常
* 一般实现的单例类都是可序列化的，可在类中加入readResolve方法，单例模式笔记也有提及

## 第四条：通过私有构造器强化不可实例化的能力
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常我们会写一些工具类，而这些类是不需要被实例化的，那么我们可以把构造器私有化，并在构造的时候抛出异常，最好在构造器里面填上注释。

## 第五条：避免创建不必要的对象
### 几个重点

* 除了重用不可变的对象之外，也可以重用那些已知不会被修改的可变对象
* 在Java 1.5版本中，有一种创建多余对象的新方法，成为自动装箱，它允许程序员将基本类型和装箱基本类型混用，按需要自动装箱和拆箱。因为我们要注意要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱

### 总结
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要错误地认为本条暗示着“创建对象的代价非常昂贵，我们应该要尽可能地避免创建对象”。相反，由于小对象的构造器只做很少量的显示工作，所以，小对象的创建和回收动作是非常廉价的，特别是在现代的JVM实现上更是如此。通过创建附加的对象，提升程序的清晰性、简洁性和功能性，这通常是件好事。反之，通过维护自己的对象池来避免创建对象并不是一种好的做法，除非池中的对象是非常重量级的，而我们使用“保护性拷贝”的条件是会导致潜在的错误和安全漏洞，而不必要地创建对象则只会影响程序的风格和性能。

## 第六条：消除过期的对象引用
### 几个注意点

* 出栈的时候清空引用，防止出现过期引用(该引用不会被GC处理)
* 内存泄漏问题：
	1. 只要类是自己管理内存，程序员就应该警惕内存泄漏问题。一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空
	2. 还有一种场景就是缓存，我们可以采用弱引用实现缓存，如WeakHashMap，LinkedHashMap。两种清除缓存无用项的方法：1.可以由一个后台线程(可能是Timer或者ScheduledThreadPoolExecutor)来定时清理，或者可以在给缓存添加新条目的时候顺便进行清理
	3. 监听器和其他回调，如在API中注册回调，却没有显式地取消注册。有个方法就是用弱引用形式来保存

## 第七条：避免使用终结方法
**终结方法(finalizer)通常是不可预测的，也是很危险的，一般情况下是不必要的。因为终结方法不能保证被及时地执行。使用终结方法会有非常严重的性能损失。**

### 总结
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非是作为安全网，或者是为了终止非关键的本地资源，否则请不要使用终结方法。

